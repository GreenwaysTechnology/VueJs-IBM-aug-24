Pre Knowledge:

1.HTML 5
2.CSS 3
3.Javascript -ES 5 and ES 6
4.Node js fundamentals - npm

Nice to have

react or angular

Lab setup:
node.js
vs code

What is vue.js?
  Vue.js is a javascript framework for building user interfaces.

User interfae:
1.desk top app
2.web apps which is running browser
3.Mobile apps
   native
   browser based
   hybrid app

   
javascript frameworks/libs for building user interfaces

1.JQuery
2.Angular js
3.React js
4.Angular 2.x 
5.Vue js
etc....

javascript frameworks for building server side apps
1.express js
2.hapi js
3.Moleculer
4.Loopback
5.nest js
............
6.Next js -react js
7.Nuxt js -vue js
etc.....

Vue is more popular for building browser based web applications.

What are different types of Web Applications?

Web History
https://home.web.cern.ch/science/computing/birth-web..

Technologies:

1.HTML 
2.HTTP protocal
3.Web server - Next Computer and Next Operating System
4.Line Mode web browser and editor

Types of Web Applications:

Server side web apps

1.Static web apps - 1989 to 1995
   -HTML
  Web app is prepared by hand written html documents, and hosted on server.

2.Dynamic Content Generation web apps -1996 to till date

   Web app is prepared by the special program called "cgi" , hosted on server.
   -CGI - C/Perl
   -J2EE - Java,JavaServlets
   -ASP  - Vbscript,VB
   -PHP  - Php

3.Web Services - ECOMMERCE(B2 to B2) - 1998 To till date
 DATA is exchanged between two systems 
  Common data formats
   -XML - SOAP web services
   -Multi format(JSON)- RESTFull Web Services / GraphQL 
.....................................................................................
			Client Side Web App
....................................................................................

1.In 2006, w3c published new spec called "HTML 5",as part of HTML5 , W3C Published new web spec called "Single Page web App" /SPA.

 html page is prepared dynamically at client side by the browser, data needed for html page is accessed with help of "REST" api.

After introduction of SPA technology many frameworks and libs were created.

1.Mustache.js
2.Angular.js
3.React
4.Angular
5.Vue.js
....................................................................................
			Vue js

Vue.js is javascript client side spa framework.


Vue vs React and Angular:
.........................

Vue brings best practices of react and angular in single place.

In React you write "UI Code called markup and application logic ,data representation" inside js.

const Counter =()=>{
  const [counter,setCounter] =useState(0)

 return <div>
	<h1>Counter {counter} </h1>
  </div>
}
In Angular you write "UI Code called markup and application logic ,data representation" separatly

 templates:'ui'
 inside class you write application

Angular has so much boiler plate code.

Vue brings every thing inside one place like templates, application logic,css files
more readable , less boiler plate code using simple /basic js syntax.

Like angular and react, "Vue" is also component driven.

Vue supports all compoent features such as "props,state"
.....................................................................................
			Vue as SPA framework - Client side technology
.....................................................................................

stack:
1.html
2.css
3.js

DOM programming:

  DOM is specification for building client side web apps, DOM spec introduced by w3c 
  DOM is implemented by js and html.

What is js and why js?

  JS is programming language , created by netscap communication , to manipulate HTML
  Document at browser.
  html is generated by server and sent to client(browser), the browser just display
  html, after display generally we cant modify the html.
  Js was created to update html after display(render) - Dynamic html technology.

 Using js if you change html at client side - DOM programming.

if you want to understand how dom works, we need to understand how html works.


HTML:
  It is also one of the programming language.

Like other languages such as c program

1.source code
  hello.c
2.compile the code
  hello.obj - compiled code
3.execute the code
  on runtime we execute the code

.....................................................................................
			How browser renders HTML
		    Internals of HTML Representation
....................................................................................

HTML is programming language -  DSL pl /declarative pl.


index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
.....................................................................................

.....................................................................................
				Runtime  -  Allocate Memory for HTML
...........................................................................................				
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c
body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree (c)

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
 |
Layout/Paint Engine: will convert nodes into pxs : final output
...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec - DOM
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be represented as Objects" : Object oriented Document Programming.

According to DOM?

Any html element is represented as "Node" inside browser engine, "Object" as inside javascript engine.

div = DIV object
.............................................................................................
				Birth of Frameworks and libs

...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?




............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.

.....................................................................................
				DOM Programming
.....................................................................................
How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
			Client side web apps and vue js
....................................................................................
Vue is client side web app framework.
but
Now a days vue can be used to build server side web apps as well

Vue js Application Types:
.........................

1.Standalone script application
    Enchancing html (generated by server) by adding js/ js lib(jquery)

 if you have traditional web apps written using server side technology like jsp,asp.net,php which "js/jquery"

   Vue js is declarative replacement of imperative "jquery"

2.Web components
   Vuejs supports to create web component based architecture applications

3.SPA
   Vue is primarily popular for building spa apps

Server side:
............
Full Stack:
  Building app using one single technology both front end and back end.
eg:
  Next.js
  Front End is react and back end is also react

  Nuxt.js
  Front end is vue and back end is also vue...

1.SSR :Server side Rending
   Full SSR
   Partial SSR
  SSR =  Server+ client => SPA(Client) + SERVER

2.SSG/Jamstack
  Static site generation.
  now a days people are building static web sites like 90's web app , in order to   improve high performance.
  Vue.js(Nuxt) can help to build SSG apps
  React.js(Next) can help to build SSG apps

You can use vue+NUXT
Based on ,use case we can pickup any one of the methods to build client side web apps, but most popular one is SPA,SSR

Vue js can be used to build any type of client side web apps(spa,ssr,ssg)
.....................................................................................
			 Getting started with Vue App
....................................................................................

What type of app we are going to build?

1.Standalone Script app
  We will see only basic level.

2.Single page web app
  We will explore very detailed

In case any app type , we need "tool" sets to create app.


There are two major tools we go with building vue.js apps

1.Without build tool
2.With build tool

1.Standalone Script app
   Without build tool.

if you plan without build tool means, you are planning to create 'standalone script'
....................................................................................
		    Project Setup- SSP (Standalone Script App)
...................................................................................

Steps

1.Creat Project

G:\IBM\2024\Aug>mkdir vue-ssp

G:\IBM\2024\Aug>cd vue-ssp

G:\IBM\2024\Aug\vue-ssp>

G:\IBM\2024\Aug\vue-ssp>mkdir src

G:\IBM\2024\Aug\vue-ssp>code .

outside src, create index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue app</title>
</head>
<body>
    <h1>Vue SSP App</h1>
</body>
</html>

After adding html we need to run html, we need web server.

Vs code has plugin called "live server" which is built in web server- You have to install "live server" plugin(Extensions)

After running, we need to add "vue js" framwork.

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>

.....................................................................................
.....................................................................................
DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)

...................................................................................
...................................................................................
How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Smaller UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

.....................................................................................
		  Vue js and DOM element creation
....................................................................................

in order to begin with vue, we need to understand some of the vue.js objects.

Vue offers lot of objects.

Vue has two major versions

1.vue 2.x - old and legacy version
2.vue 3.x - modern and latest version

 There is lot of difference in vue 2 and vu3.
 we are going to discuss  both versions by comparsion.

1.Application Object/Vue instance

Pro Vue 3. (in vue 2.x)
var app = new Vue({   })


Vue 3:
1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

.....................................................................................
			  A.Via Global Vue Instance variable	


How to get Vue instance?
 First we have to get Vue instance then only we can create application.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provied by vue framework
        let vue = Vue
        console.log(vue)
    </script>
</body>

</html>

Vue instance is having so many methods(apis)
............................................

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

What is Application Object?

  Application object is object which is container object which encapsulate vue app.

How to create Application Object?

 in order to create application object, we need to get vue instance first.
How to create Application Object?

 in order to create application object, we need to get vue instance first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provied by vue framework
        let vue = Vue
        console.log(vue)
        //Vue Application object
        const app = vue.createApp()
        console.log(app)
    </script>
</body>

</html>
.....................................................................................
			B.Via ES 6 Modules
.....................................................................................

ES 6 module:
  import , export ,export default.

Can we use es6 modules directly inside browser?

No, in old browsers

Yes in modern browsers

Generallly browser has no facility to links files and share code using E6 modules keyword.

How to run es 6 modules based apps inside browsers

1.via build tools.
  webpack,roolup....

2.without build tool
   using browser only
  using script tag

eg
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="src/index.js" type="module"></script>
</body>
</html>

src/index.js
import { name } from "./name.js";

console.log(name)

src/name.js

export const name='Subramanian'
..................................................................................
			 ES 6 modules and html 
....................................................................................

in the last example we have used import and export  keywords inside js

Inside html we have used js via <script src="src/index.js" type="module"> 

Can we import js inside html directly?

Yes! we can

if you want to import any js code within html file, we have to use there is option called "importmap" option.


Syntax:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="importmap">
        {
            "imports":{
                
            }
        }
    </script>
</head>
<body>
    <!-- <script src="src/index.js" type="module"></script> -->
</body>
</html>

eg:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="importmap">
        {
            "imports":{
                "name":"./src/name.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import { name, age } from 'name'
        console.log(name, age)
    </script>
</body>

</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>


eg:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports":{
                "name":"./src/name.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import { name, age } from 'name'
        console.log(name, age)
    </script>
</body>

</html>
....................................................................................
			  Vuejs framework and es 6 module syntax


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports":{
                "name":"./src/name.js",
                "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import { name, age } from 'name'
        import { createApp } from 'vue'
        console.log(name, age)
        const app = createApp()
        console.log(app)
    </script>
</body>

</html>
....................................................................................
			First User interface
.....................................................................................
Components:
  Representation of Userinterface.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports":{
                "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
        }
    </script>
</head>

<body>
    <div id="root">
        
    </div>
    <script type="module">
        //import factory method called createApp
        import { createApp } from 'vue'
        // Create dom element and insert into existing dom tree
        // create app instance
        const app = createApp({
            template:`
                <h1>Hello,Vue</h1>
            `
        })
        //console.log(app)
        app.mount("#root")
    </script>
</body>

</html>
.....................................................................................
			  User interface Development
.....................................................................................

User interface development guidelines:

1.User interface must be broken into smallar and smallar -  Compostion - Component model

2.User interface is organized in hierachal structure -  Tree Structure 
  Thats where html has been designed.
 We need to follow html tree model

 <div>
    <div>
	<div>
	   
	</div>
	
    </div>
 </div>

3.In tree model there must be one root element
..................................................................................

			Root Component(root Element)


Component Representations:

In React:
function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }

In Vue:
 Component is literal object.

const Logo = { 

}

What component contains.

 Component information can be categorized into various segments.


1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions


2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends

Misc
name
inheritAttrs
components
directives

Component Instance api
$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()

eg:

 const Logo = {
  ui:{},
  state:{},
  others:{},
  methods:{}
 }
.....................................................................................
			 Vue Application Setup using build tools
.....................................................................................
Build tools are js based tools for create,manage js apps work flows.
Build tools based on npm tool.

Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.


We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates

>npm init vue@latest

vue-cli
 old pattern
vite
 modern pattern - recommended
 npm init vue@latest

This is abstraction for vite based project templates
 
G:\IBM\2024\Aug\vuejs>npm init vue@latest
Need to install the following packages:
create-vue@3.10.4
Ok to proceed? (y) y


> npx
> create-vue


Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes
√ Add Vue DevTools 7 extension for debugging? (experimental) ... No / Yes

Scaffolding project in G:\IBM\2024\Aug\vuejs\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev


G:\IBM\2024\Aug\vuejs>cd vue-app

G:\IBM\2024\Aug\vuejs/vue-app>npm i

G:\IBM\2024\Aug\vuejs/vue-app>npm run dev


Project Structure:

package.json
{
  "name": "vue-app",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.4.29"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.5",
    "vite": "^5.3.1",
    "vite-plugin-vue-devtools": "^7.3.1"
  }
}
....

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

vite-config.js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    vueDevTools(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

src - source folder
  |
  assets -  folder where we keep global css and image fiels
  components -  where we can keeps components of app
  App.vue
  main.js -  always must be .js file- entry

App.vue
  All Components must be saved "ComponentName.vue"
App Root Component for the application

main.js 
import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
....................................................................................
			 Vue coding style
....................................................................................

Vue coding can be classified into two category.

Vue 2.x and Vue 3.x

API classification:

1.Options API based Style - Vue 2.x and Vue 3.x
2.Composition API Based Style - Vue 3.x style
.....................................................................................
			 Components and Components creational Pattern
.....................................................................................

1.Plain java script pattern

App.js
export default {
  ....options
}
It is more imperative way of creating components

2.Single File Component Pattern - SFC Pattern

 It is more declarative way of creating components

 As name suggest, All component logic inside single file

Every Component have three major segement

1.template
   Collection of html elements and vue instructions

2.javascript
   colllection of variables,methods/functions

3.style
  css style for a component.

In Single File Component, we isloate very clearly into three sections

<script>
 // all js code 
</script>
<template>
  template code - html code
</template>
<style>
 css style for component
</style>

.....................................................................................
	      Plain javascript is usefull where there is no build workflow
		     SFC is usefull where there is build work flow		   

	      Plain javascript components are saved with "FileName.js" extension
	       SFC Components are saved with "FileName.vue" extension
...................................................................................

Plain javascript:
................
src/components/App.js

//component must be exported using export default

export default {
    template:`
        <h1>Vue Component</h1>
    `
    //rest of the options goes here
}
 
index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports":{
                "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js",
                "app":"./src/components/App.js"
            }
        }
    </script>
</head>

<body>
    <div id="root">

    </div>
    <script type="module">
        import { createApp } from 'vue'
        import App from 'app'
        //inject root component
        const app = createApp(App)
        app.mount("#root")
    </script>
</body>

</html>
.....................................................................................				Component Composition
.....................................................................................

App -Root Component
 |
 Welcome Component


src/components/Welcome.js
export default {
   template: `
        <h1>Welcome To Vue Application</h1>
    `
}

src/components/App.js
import Welcome from "./Welcome.js"

//component must be exported using export default
export default {
    components: {
        Welcome
    },
    template: `
        <h1>Vue Component</h1>
        <Welcome></Welcome>
    `
    //rest of the options goes here
}
...

Assigment:

Build layout

  Page
   |
   Header
   Body
     Section1,Section2,Section3	
   Footer
.....................................................................................			             SFC Pattern
.....................................................................................

SFC pattern file, contains three segments.


1.template
   Collection of html elements and vue instructions

2.javascript
   colllection of variables,methods/functions

3.style
  css style for a component.

In SFC pattern, we isloate very clearly into three sections

SFC files are saved with ".vue" extension.


<script>
 // all js code 
</script>
<template>
  template code - html code
</template>
<style>
 css style for component
</style>

Eg:
<script>
 
</script>
<template>
  <div>
     <h1>Hello Vue</h1>
  </div>
</template>
<style>
</style>
...................................................................................
			 "Going foward we focus only  SFC pattern "
....................................................................................
Inside SFC, we can use either use "Options API" based style or "Composition API" based style.

			Commonality between both patterns
			 (Options API and Composition API)

1.Code segmentation is same for both patterns

<script>
 // all js code 
</script>
<template>
  template code - html code
</template>
<style>
 css style for component
</style>

.....................................................................................
			Options API pattern
.....................................................................................

In Options API pattern we return Object called "Option" Object,  which contains necessary configuration.

<script>
 export default {
     //options 
     
 }
</script>

Sample Configuration(Options)

<script>
 export default {
   components:[],
   props:['something']
   data() {
     return {}
   }
 }
</script>
.....................................................................................
			Composition API Pattern
.....................................................................................

=>It is vue 3.x style of writing code.
=>In this pattern, we define a component logic's using imported api functions
=>In this pattern, we can write js directly within script tag.
=>In composition pattern we have two style of coding.

		
			Composition API pattern
				|
	------------------------------------------------------------
        |                                                          |
   with setup function                                     with set attribute


with setup function:

1.It looks like Options api pattern but code refactoring has been done.
2.It looks like imperative style of compostion api.

<script>
// compostion api pattern;using setup function
export default {
    setup() {
        //all js initalization code will go
    }
}
</script>
<template>
    <h1>Compostion API pattern using setup function</h1>
</template>
<style></style>

with setup attribute:
.....................
=>It is same as setup function only but it is more declarative.
=>It has been built on the top of setup function...
=>We dont need to write extra code, vue compiler will write for us.

<script setup>
 //js code will go here
</script>
<template>
    <h1>Compostion API pattern using setup function</h1>
</template>
<style></style>

  				     Vue App
		   			|
			---------------------------------------  
			With Build tool                  Without build tool
				 |				|
			  SFC Component            	 Standalone script App
				|
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                     	|
	      	with setup function                           with setup attribute



.....................................................................................
			SFC- Options API
.....................................................................................

1.Component Composition:

src/components/Hello.vue
<script>
</script>
<template>
    <div>
        <h1>Hello</h1>
    </div>
</template>
<style>
</style>
<script>
import Hello from './Hello.vue'
export default {
    components: {
        Hello
    }
}
</script>
<template>
    <Hello/>
</template>
<style>

</style>

src/App.vue

<script>
import Greeter from './components/Greeter.vue'
export default {
components: {
    Greeter
}
}
</script>
<template>
  <div>
    <Greeter/>
  </div>
</template>
<style>
</style>

Task:
Build layout like header,body with sections, with footer.
.....................................................................................
			SFC- Composition API -setup function
.....................................................................................

setup function:
...............

src/components/Address.vue
<script>
export default {
  setup() {},
};
</script>
<template>
  <div>
    <address>
      <p>10th street</p>
      <p>Gandhi Nagar</p>
      <p>Coimbatore</p>
      <p>Tamil Nadu</p>
    </address>
  </div>
</template>
<style></style>

src/components/User.vue
<script>
import Address from "./Address.vue";
export default {
  components: {
    Address,
  },
  setup() {},
};
</script>
<template>
  <div>
    <h1>User</h1>
    <h2>Subramanian</h2>
    <Address />
  </div>
</template>
<style></style>

src/App.vue
<script>
import User from './components/User.vue'
export default {
components: {
    User
},
setup(){

}
}
</script>
<template>
  <div>
    <User />
  </div>
</template>
<style></style>

.....................................................................................
			SFC- Composition API -setup attribute
.....................................................................................

src/components/Product.vue
<script setup>
</script>
<template>
    <h1>
        Product Page
    </h1>
</template>
<style>
</style>

src/components/Customer.vue
<script setup>
import Product from './Product.vue'
</script>
<template>
    <div>
        <h1>Customer Page</h1>
    </div>
    <Product/>
</template>
<style>
</style>

src/App.vue
<script setup>
import Customer from "./components/Customer.vue";
</script>
<template>
  <Customer />
</template>
<style></style>
....................................................................................
Task:
 Build layout  with Composition API using setup fun and setup attribute
.....................................................................................
		      Components -Registration -Advanced
.....................................................................................

A Vue Components needs to be "registered"  so that vue knows to locate its implementation when it is encountered in a template.

export default {
  components: { Hello}
}

<template>
   <Hello/>
</template>

Types of Registration:

1. Global Registration
 if components are registried globally, those components are called as "Global"
 Components

2. Local Registration
 if components are registried locally, those components are called as "Local"
 Components
eg:
export default {
  components: { Hello}
}

<template>
   <Hello/>
</template>

1. Global Registration /Global Components.

Application Object:
..................
 It is a container object which contains other objects (components...etc)

How to create Application Object?

 const app = createApp(RootComponent)

Here "app" is just variable points application Object

Application Object having lot of methods:

1.app.component()
2.app.use()
3.app.directive()
etc...

Global Components:
 Global comonents are created with application object

import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

app.component('my-component',{
  //component config
})
or

StatusBar.vue

app.component(StatusBar)

app.mount("#app")

//Retrive the Registred Component
const MyComponent = app.component('my-component',{
  //component config
})


eg;

src/components/StatusBar.vue
<script setup></script>
<template>
    <h2>Status Bar</h1>
</template>
<style>
</style>

src/main.js
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/StatusBar.vue'

const app = createApp(App)
//Global Component
app.component('StatusBar', StatusBar)

app.mount("#app")

//createApp(App).mount('#app')


How to use Global Component?

In Options Api:
..............
<script>
// import StatusBar from './components/StatusBar.vue'
export default {
    // components: {
    //     StatusBar
    // }
};
</script>
<template>
  <StatusBar />
</template>
<style></style>

Note:
 import statement is not necessary for global components.


In Composition Api:

Using setup fun:
<script>
// import StatusBar from './components/StatusBar.vue'
export default {
  setup() {},
};
</script>
<template>
  <StatusBar />
</template>
<style></style>

Using setup attribute:
<script setup>
// import StatusBar from './components/StatusBar.vue'
</script>
<template>
  <StatusBar />
</template>
<style></style>


Note:
 import statement is not necessary for global components.
.....................................................................................
			 Global Components vs Local Components
.....................................................................................
=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").

=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.
		....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).

This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   
	Vue supports both cases , but highly recommened is Pascal Case

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where


eg:

<script setup>
</script>
<template>
    <!-- Pascal Case -->
  <StatusBar />
  <!-- keb-case -->
   <status-bar></status-bar>
</template>
<style></style>
.....................................................................................
				Templates
....................................................................................

Template is representation of "View"

View is runtime representation of user interface
View is Typically DOM tree.

Types of templates:

1.Static template
   It is havingl only pure html tags

2.Dynamic templates
   Template is having html code and vue instructions

Vue instructions are special symbols and notations.


Data Binding:
   Passing data from the component to view  and View to component.


Types of data binding:
1.Interpolation
2.Property and props Binding
3.Attribute Binding
4.Event Binding
5.Two way data binding
6.Class and Style binding
....................................................................................
			 Design patterns in Vue.js

1.Angular uses "MVC" pattern
2.React uses "Flux" Pattern
3.Vue.js uses "MVC" pattern

M-Model- data
V-View - Presentation
C-Controller

MVC In Vue:
...........

<script>
   M + C ->logic
</script>
 
<template>
   View logic
</template>

<style>

</style>

Component encaspulate Model + Controller + View
.....................................................................................
				Interpolation
.....................................................................................

Transfering data (state) from controller to View.

State :
  State can be represented in 2 ways

1.Primitives
   numbers,strings,booleans
2.Objects and Collections
   literal object and arrays

.....................................................................................
			Interpolation - SFC - Options API Pattern
.....................................................................................
  
Create new project

npm init vue@latest

Data configuration:

let options = {
 data: ?
 props: ?
 methods: ?

}
basic syntax: ES 5 Syntax
export default {
  data:function(){
    return {} //state object
  }

}

basic syntax: ES 6 Syntax
export default {
  data(){
    return {} //state object
  }

}

eg;
<script>
export default {
  components: {},
  data() {
    //you must return object
    return {
      name: "Subramanian",
    };
  },
};
</script>
<template>

</template>
<style></style>

How to bind /show the variable inside view?
 {{Variable}} - interpolation

<script>
export default {
  components: {},
  data() {
    //you must return object
    return {
      name: "Subramanian",
    };
  },
};
</script>
<template>
 <h1>Your name is {{name}}</h1>
</template>
<style></style>
....................................................................................

More data
<script>
export default {
  components: {},
  data() {
    //you must return object
    return {
      firstName: "Subramanian",
      lastName: "Murugan",
      status: true,
      address: {
        city: "Coimbatore",
        state: "Tamil nadu",
      },
    };
  },
};
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available"}}</h2>
    <p>
     {{address.city}},
    </p>
     <p>
     {{address.state}}
    </p>
  </div>
</template>
<style></style>
.....................................................................................
			Interpolation - SFC - Composition API Pattern
.....................................................................................

Using Setup function:
.....................

<script>
 setup(){
   return {} //state object
 }
</script>

<script>
export default {
  components: {
    
  },
  setup() {
    let firstName = "Subramanian";
    let lastName = "Murugan";
    let status = true;
    let address = {
      city: "Coimbatore",
    };
    //return state object
    return {
      firstName,
      lastName,
      status,
      address,
    };
  },
};
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <p>{{ address.city }},</p>
    <p>
      {{ address.state }}
    </p>
  </div>
</template>
<style></style>


Using Setup attribute:
......................
<script setup>
let firstName = "Subramanian";
let lastName = "Murugan";
let status = true;
let address = {
  city: "Coimbatore",
};
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <p>{{ address.city }},</p>
    <p>
      {{ address.state }}
    </p>
  </div>
</template>
<style></style>
....................................................................................
			Component Composition and Data binding
.....................................................................................

Options API:
src/components/Address.vue
<script>
export default {
  components: {},
  data() {
    return {
      address: {
        city: "Coimbatore",
        state: "Tamil nadu",
      },
    };
  },
};
</script>
<template>
  <p>{{ address.city }},</p>
  <p>
    {{ address.state }}
  </p>
</template>
<style></style>

src/components/Profile.vue
<script>
import Address from './Address.vue'
export default {
  components: {
    Address 
  },
  data() {
    return {
      firstName: "Subramanian",
      lastName: "Murugan",
      status: true
    };
  },
};
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <Address/>
  </div>
</template>
<style></style>

src/App.vue
<script>
import Profile from './components/Profile.vue'
export default {
  components: {
    Profile
  },
}
</script>
<template>
   <Profile/>
</template>
<style></style>
.....................................................................................
Composition API : Setup fun:
.............................
src/components/Address.vue
<script>
export default {
  components: {},
  setup () {
  let address ={
        city: "Coimbatore",
        state: "Tamil nadu",
      },
    return {
        address
    }
  }
};
</script>
<template>
  <p>{{ address.city }},</p>
  <p>
    {{ address.state }}
  </p>
</template>
<style></style>
	

src/components/Profile.vue

<script>
import Address from "./Address.vue";
export default {
  components: {
    Address,
  },
  setup() {
    let firstName = "Subramaian";
    let lastName = "Murugan";
    let status = true;
    return {
      firstName,
      lastName,
      status,
    };
  },
};
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <Address />
  </div>
</template>
<style></style>


src/App.vue
<script>
import Profile from "./components/Profile.vue";
export default {
  components: {
    Profile,
  },
  setup() {},
};
</script>
<template>
  <Profile />
</template>
<style></style>
.................................................................................

Using setup attribute:

src/components/Address.vue

<script setup>
let address = {
  city: "Coimbatore",
  state: "Tamil nadu",
};
</script>
<template>
  <p>{{ address.city }},</p>
  <p>
    {{ address.state }}
  </p>
</template>
<style></style>


src/components/Profile.vue

<script setup>
import Address from "./Address.vue";
let firstName = "Subramaian";
let lastName = "Murugan";
let status = true;
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <Address />
  </div>
</template>
<style></style>

src/App.vue
<script setup>
import Profile from "./components/Profile.vue";
</script>
<template>
  <Profile />
</template>
<style></style>
.....................................................................................
			    Directives
......................................................................................

What is Directive?
  Directive is object which helps to create custom elements and attributes
 Directives enchances existing html elements- We can extend the basic functionality of HTML elemements.
 We are going to add new behaviour to the HTML Elements.


Custom elements and attributes:
................................
<h1>Hello</h1>
  h1 is built in html element, it is part of the html language.

HTML runtime:

 When html runtime encounters h1 element, it knows how to represent.

<hello>
<profile>
<address>
   These are looks like html elements but not.
  Html runtime when encounters these elements, internally it throws Runtime Error 
 Called " UnKnownElementException"
 
  if UnKnownElementException is thrown, browser automatically converts it into "PlainText" Node, renders it.

In 2007, w3 introduced  new feature called "Custom element Feature", Accordint to custom element, we can introduce custom element.

How to teach browser to understand custom element?
 Via "Javascript".

w3c introduced new api called customElements.define("popup-info",PopupInfo);

Custom attributes:

Similar to custom elements we can custom attributes also,through which we can add new meaning to existing html elements.

<div style>
      |
    attribute - built in

<div my-if> 
     |
    custom attribute

In frameworks like angular and vue, we have feature called directives(custom elements and custom attributes).

		"Every Component is custom element/directive"

<app-drawer>
<profile> ----------| js code--- runs---renders in the browser


<app-drawer> ---|JS Code--->Runs ---renders in the browser....

eg:
<script setup>
import AppDrawer from './components/drawer/AppDrawer.vue'
</script>
<template>
<h1>Drawer App</h1>
<!-- Custom element -->
<app-drawer></app-drawer>
</template>
<style>

</style>

src/componnets/drawer/AppDrawer.vue
<script setup>
</script>
<template>
    <p>Drawer Element</p>
</template>
<style>
				Directives
		------------------------------------------------
		|                                              |
	 Custom Element                                    Custom attribute  
         (Component)                                       (Attibute directive)
  .....................................................................................
			 Custom attribute  


1.Built in element Attributes

 <img src="" alt="">
       |      |
   Attributes - Built in attributes

Browser knows how to put logic to src and alt.

2.Custom attributes on existing html elements

<img customAttribute />
        | 
     custom attribute
How to teach browser to parse custom Attributes 
  "Through Javascript"

eg: Vue rendered page:

<div id="app" data-v-app="">

.....................................................................................
	Vue.js Helps to add Custom attributes on existing elements via "Directives" -		    	       Attribute Directives
.....................................................................................
Vue js attribute directive syntax:

v-directiveName


Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is

Built in custom elements(custom directives/components)
.......................................................
<Transition>
<TransitionGroup>
<KeepAlive>
<Teleport>
<Suspense>

Special Elements
<component>
<slot>
<template>
.....................................................................................				v-text and v-html
.....................................................................................
v-html => Innerhtml
v-text => innerText
It is alernate to interpolation.

v-text and v-html both are same

 v-text inserts content as "plain text node"
 v-html inserts content as "html node"

<script setup>
const name = "Subramanian";
</script>

<template>
  <h1>Interpolation using "`Double Curly braces`" notation</h1>
  <h2>Name {{ name }}</h2>
  
  <h1>Interpolation using Directive vtext</h1>
  <h2 v-text="`Name ${name}`"></h2>

  <h1>Interpolation using Directive vhtml</h1>
  <h2 v-html="`Name ${name}`"></h2>
</template>
<style></style>
...................................................................................
			v-bind
..................................................................................

v-bind attach html attributes or components values dynamically.

Binding means attach value to the attribute.

Types of binding

1.static binding
2.dynamic binding

1.static binding

 <img src="logo.png">
  
   here the value of src cant be changed once it is rendered
 

2.dynamic binding

  <img v-bind:src="variableHoldingImageValue"/>

  let variableHoldingImageValue="logo.png"

 v-bind:src
   is dynamic binding, that src value can be changed dynamically.


eg:
<script setup>
const imgUrl = "/src/assets/logo.svg";
const isHidden = true;
const isEnabled= false 
</script>

<template>
  <div>
    <h1>Static Binding</h1>
    <img src="./assets/logo.svg" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic Binding</h1>
    <img v-bind:src="imgUrl" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic binding with show and hide</h1>
    <article v-bind:hidden="isHidden">This is article</article>
  </div>
  <div>
    <h1>Dynamic binding with enable and disable</h1>
    <button v-bind:disabled="isEnabled">button</button>
  </div>
</template>
<style></style>
.....................................................................................
			Code Refactoring for v-bind Directive
.....................................................................................

Full syntax
<button v-bind:disabled="isEnabled">button</button>

Short cut:
<button :disabled="isEnabled">button</button>


Eg:
<script setup>
const imgUrl = "/src/assets/logo.svg";
const isHidden = true;
const isEnabled = false;
</script>

<template>
  <div>
    <h1>Static Binding</h1>
    <img src="./assets/logo.svg" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic Binding</h1>
    <img :src="imgUrl" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic binding with show and hide</h1>
    <article :hidden="isHidden">This is article</article>
  </div>
  <div>
    <h1>Dynamic binding with enable and disable</h1>
    <button :disabled="isEnabled">button</button>
  </div>
</template>
<style></style>
.....................................................................................
			  Property binding- props binding
....................................................................................

Component contains 
1.user interface
2.data 

if you create component which contains ui and data, after rendering if you want to supply different data for that component not possible.

if i create profile component

<script setup>
import Address from "./Address.vue";
let firstName = "Subramaian";
let lastName = "Murugan";
let status = true;
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <Address />
  </div>
</template>
<style></style>

here firstName,lastName ,status is "tightly coupled" with this component.

what if i want to display different profile information,you cant reuse the component

Solution:
  You should create component that should be configurable.

You have to pass different data to the component during runtime.

How to configure the component which accepts data?

  "Props or or property pattern.

Props or property is way of passing data to the component.

Props are passed from the parent component to child component.
.....................................................................................
			Props and Options api
.....................................................................................

Props Pattern

Syntax:

From the parent compoenent template

<template>
   <Child  title="value" :value="variable" />
</template>

  <Child  title="value" :value="variable" />
	   |              |
        props           props="variable"

here title is property which value is static
:value is also property which value is dynamic


eg:

child Component

src/comonents/User.vue
<script>
export default {
  components: {},
  props: ["id", "name", "email"],
};
</script>
<template>
  <div>
    <h1>User information</h1>
    <h2>Id {{ id }}</h2>
    <h2>Name {{ name }}</h2>
    <h2>Email {{ email }}</h2>
  </div>
</template>
<style></style>


Parent Component
src/App.vue
<script>
import User from "./components/User.vue";
export default {
  components: {
    User,
  },
  data() {
    return {
      id: 3,
      name: "Ram",
      email: "ram@gmail.com",
    };
  },
};
</script>
<template>
  <div>
    <!-- Static Property -->
    <User id="1" name="subu" email="subu@gmail.com" />
    <User id="2" name="murugan" email="murugan@gmail.com" />
    <!-- Dynamic property -->
    <User :id="id" :name="name" :email="email" />
  </div>
</template>
<style></style>
.....................................................................................
			Props and Composion api
.....................................................................................
setup function:

Child Component

src/components/User.vue
<script>
export default {
  components: {},
  props: ["id", "name", "email"],
  setup() {
    
  },
};
</script>
<template>
  <div>
    <h1>User information</h1>
    <h2>Id {{ id }}</h2>
    <h2>Name {{ name }}</h2>
    <h2>Email {{ email }}</h2>
  </div>
</template>
<style></style>


Parent
src/App.vue
<script>
import User from "./components/User.vue";
export default {
  components: {
    User,
  },
  setup() {
    
    return {
      id: 3,
      name: "Ram",
      eamil: "ram@gmail.com",
    };
  },
};
</script>
<template>
  <div>
    <!-- Static Property -->
    <User id="1" name="subu" email="subu@gmail.com" />
    <User id="2" name="murugan" email="murugan@gmail.com" />
    <!-- Dynamic property -->
    <User :id="id" :name="name" :email="email" />
  </div>
</template>
<style></style>
.....................................................................................
			Props and Composition API-Setup Attribute
....................................................................................
Setup attribute offers , a special function called "defineProps"

src/components/User.vue
<script setup>
const props = defineProps(["id", "name", "email"]);
</script>
<template>
  <div>
    <h1>User information</h1>
    <h2>Id {{ props.id }}</h2>
    <h2>Name {{ props.name }}</h2>
    <h2>Email {{ props.email }}</h2>
  </div>
</template>
<style></style>

src/App.vue
<script setup>
import User from "./components/User.vue";
let id =1;
let name="karkthi"
let email="karthik@gmail.com"
</script>
<template>
  <div>
    <!-- Static Property -->
    <User id="1" name="subu" email="subu@gmail.com" />
    <User id="2" name="murugan" email="murugan@gmail.com" />
    <!-- Dynamic property -->
    <User :id="id" :name="name" :email="email" />
  </div>
</template>
<style></style>
.....................................................................................
			Property Validation -Composition setup attribute
.....................................................................................

Some times i want to enforce the property data type validation, which is only for runtime verification.

For eg:
 I have property called age
 i need to define rule for age that must be be number, it should not be string.

Simple Syntax:

1.defineProps(['age','name'])

Validation Syntax:

2.defineProps({
 age:Number,
 id:[Number,String] //can be string or can be number
 name:{ 
   type:String,
   required:true,
   default:'foo'
  
 },
 status: {
   validator(value){
      return ['OK','NOTOK','Success','Failure'].includes(value)
   }
 }
})


Runtime data types:
1.Number
2.String
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol


Eg:
src/components/User.vue
<script setup>
const props = defineProps({
  id: [Number, String],
  name: String,
  email: String,
  status: {
    validator(value) {
      return ["Available", "NotAvailable"].includes(value);
    },
  },
});
</script>
<template>
  <div>
    <h1>User information</h1>
    <h2>Id {{ props.id }}</h2>
    <h2>Name {{ props.name }}</h2>
    <h2>Email {{ props.email }}</h2>
    <h2>Status {{ props.status }}</h2>
  </div>
</template>
<style></style>





src/App.vue
<script setup>
import User from "./components/User.vue";
let id =1;
let name=34
let email="karthik@gmail.com"
let status ="Available"
</script>
<template>
  <div>
    <!-- Static Property -->
    <User id="1" name="subu" status="Available" email="subu@gmail.com" />
    <User id="2" name="murugan" status="Available" email="murugan@gmail.com" />
    <!-- Dynamic property -->
    <User :id="id" :name="name" :status="status" :email="email" />
  </div>
</template>
<style></style>


After running you can see in the console

App.vue?t=1722573470334:56 [Vue warn]: Invalid prop: type check failed for prop "name". Expected String with value "34", got Number with value 34. 
  at <User id=1 name=34 status="Available"  ... > 
  at <App>

It shows only warning not error, because js verifies the type only during runtime.
....................................................................................
			Default Props
....................................................................................

if you dont pass value from parent to child as prop, the default prop can be supplied

src/components/Header.vue
<script setup>
const props = defineProps({
  title: {
    default: "IBM",
  },
});
</script>
<template>
  <header>
    <h1>{{ props.title }}</h1>
  </header>
</template>
<style></style>

src/App.vue
<script setup>
import Header from "./components/Header.vue";
</script>
<template>
  <Header />
  <Header title="google" />
</template>
<style></style>

..................................................................................
			One way Data Flow model
...................................................................................

All Props are passed from parent to child, where child component update the properties?
			"Props are read only"


src/components/Header.vue
<script setup>
const props = defineProps({
  title: {
    default: "IBM",
  },
});
//update the props
props.title = "Microsoft";
</script>
<template>
  <header>
    <h1>{{ props.title }}</h1>
  </header>
</template>
<style></style>


src/App.vue
<script setup>
import Header from "./components/Header.vue";
</script>
<template>
  <Header title="google" />
</template>
<style></style>

Output:
[Vue warn] Set operation on key "title" failed: target is readonly. Proxy(Object) {title: 'google'}
....................................................................................

Case Study:

You have to create Customer Component having customer details

1.Basic Customer information -  id,firstName,lastName,status
2.Address - street,city,state,country,zipcode
3.Avatar -Customer Image
4.Location - lat,lng

App-->props--Customer--->Address,Avatar,Location
................................&&&&&&&&&&&&&&&&&....................................
			Even Handling - Event binding
....................................................................................
Event handling is one of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events  are signals triggered by user or system, send to os system, the software or hardware reacts according to the event.

Events are classified into two category

1.Hardware events
   Triggered by user or system, interacts with hardware devices   
eg:
  Mouse events
    onclick,ondblclick,onmouseenter...
  https://www.w3schools.com/jsref/obj_mouseevent.asp
  Keyboard events
   onkeypress,onkeydown
  https://www.w3schools.com/jsref/event_onkeypress.asp
  Touch events
  ontouchstart,ontouchend
  https://www.w3schools.com/jsref/obj_touchevent.asp

2.Application events
   attached with objects called dom objects
  onload,oncomplete
...................................................................................
		        How event handling works

Event handling has been designed based on the design pattern called "pub-sub"/observer design pattern.

There are two actors:
1.Producer
   The producer is something who sends signals(events - name of the event and data assoicated) to the listener
2.Listener
  The Listener is someone who waits/listens for event.
  Once the event is given who reacts/respond

In js :
 Listener is function.

//event is just reference to the Event Object having information about event, and data
function listener(event){
     event.target.value
}
event object is a bridge between producer and listener

In javascript , events are given by language itself.

events are started with "on+eventName" - 
 onclick="listener"

addEventListener('click',listener)
listeners are plain js functions with event object reference arg

Frameworks like vue,react,angular who adds their own abstractions.

We can attach event on any dom element which could be application or hardware
...................................................................................

Vue Js and event handling:
..........................

Vue attaches events with any element with help of directive
                          "v-on"

Syntax:
1. v-on:NameOftheEvent="listener" -  v-on:click="update"
2. @click="listener" - @click="update"
.....................................................................................		 	Event Handling (Declration)-Options API Pattern
.....................................................................................

create new project

npm init vue@lastest
   vue-eventhandling  

Simple Event handler declaration:

src/App.vue
<script>
export default {
  components: {},
  data() {
    return {};
  },
  //listener
  methods: {
    //hello listener
    hello(evt) {
      console.log("hello is called");
    },
    hai(evt) {
      console.log("hai is called");
    },
  },
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>

.....................................................................................		 Event Handling (Declration)-Composition API Pattern -Setup function
.....................................................................................

src/App.vue
Simple Event Declaration:
<script>
export default {
  setup() {
    //event handler
    function hello() {
      console.log("hello");
    }
    function hai() {
      console.log("hai");
    }
    //must return function
    return {
      hello,
      hai,
    };
  },
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>


Arrow version of Event handler:
<script>
export default {
  setup() {
    //event handler : ES 5 Syntax
    const hello = (evt) => {
      console.log("hello");
    };
    const hai = (evt) => {
      console.log("hai");
    };
    //must return function
    return {
      hello,
      hai,
    };
  },
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>

....................................................................................		 Event Handling (Declration)-Composition API Pattern -Setup attribute
.....................................................................................

<script setup>
const hello = (evt) => {
  console.log("hello");
};
const hai = (evt) => {
  console.log("hai");
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>
.....................................................................................
		 How to attach more than one listener on single DOM Element
...................................................................................

<dom v-on:eventName="listener" v-on:eventName="listener">
<dom @eventName="listener" @eventName="listener">

<dom v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">

<script setup>
const onMouseEnter = (evt) => {
  console.log("enter");
};
const onMouseLeave = (evt) => {
  console.log("leave");
};
</script>
<template>
  <div v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">
        Touch Me
  </div>
</template>
<style></style>
....................................................................................
		  How to pass data to the listener function
..................................................................................
<script setup>
const onUpdate = (name) => {
  console.log(name);
};
</script>
<template>
  <button @click="onUpdate('Subramanian')">Send</button>
</template>
<style></style>

What if i want to pass event object also.

<script setup>
const onUpdate = (name,evt) => {
  console.log(name);
};
</script>
<template>
  <button @click="onUpdate('Subramanian',$event)">Send</button>
</template>
<style></style>
....................................................................................
			 State (Reactive State) and Event Handling
....................................................................................

We have seen how to represent data, but we have not seen how to change data.

.....................................................................................
			State Mutation(update) in Options API
.....................................................................................

src/components/Counter.vue

<script>
export default {
  data() {
    //reactive state
    return {
      counter: 0,
    };
  },
  methods: {
    inc() {
      //access reactive state variable inside listener
      this.counter++; //mutation happens
    },
  },
};
</script>
<template>
  <div>
    <h1>Counter App</h1>
    <h2>Value : {{ counter }}</h2>
    <button @click="inc">+</button>
  </div>
</template>
<style></style>

src/App.vue
<script>
import Counter from "./components/Counter.vue";
export default {
  components: {
    Counter,
  },
};
</script>
<template>
  <Counter />
</template>
<style></style>
.....................................................................................
		       Multi State-Options API
.....................................................................................

src/components/Review.vue
<script>
export default {
  data() {
    //reactive state
    return {
      like: 0,
      dislike: 0,
    };
  },
  methods: {
    onLike() {
      //access reactive state variable inside listener
      this.like++; //mutation happens
    },
    onDislike() {
      //access reactive state variable inside listener
      this.dislike++; //mutation happens
    },
  },
};
</script>
<template>
  <div>
    <h1>Review App</h1>
    <h2>Like : {{ like }} Dislike {{ dislike }}</h2>
    <button @click="onLike">Like</button>
    <button @click="onDislike">DisLike</button>
  </div>
</template>
<style></style>

src/App.vue

<script>
import Review from "./components/Review.vue";
export default {
  components: {
    Review,
  },
};
</script>
<template>
  <Review />
</template>
<style></style>





